假设存在的糖果种类有：price = [21,5,8,1]，礼盒内的糖果种类有：k = 3

由此组合出所有可能的礼盒：[21,5,8]、[21,5,1]、[21,8,1]、[5,8,1]
各礼盒内糖果价格的差值为：(16,3,13)、(16,4,20)、(13,7,20)、(3,7,4)
然后再选出各礼盒内差值【最小】的差值代表礼盒的甜蜜度：3、4、7、3
最后再挑选出【最大】甜蜜度的礼盒：也就是甜蜜度为7的（[21,8,1]礼盒）

明白题意后，我们可以先把价格排序，那么转变一下思路，我要求的答案范围就在 [0, priceMax - priceMin] 之间。那么这种 “最小”和“最大”并且还“有序”是不是就能二分出答案了。
所以我们就初始化：
1. 左边界是 0，右边界是 priceMax - priceMin；
2. 先假设一个甜蜜度 mid，然后尝试在排好序的 price 中找出 k 种糖果
3. 如果可以找到这样的 k 种糖果，则说明可能存在更大的甜蜜度，需要修改二分查找的左边界;如果找不到这样的 k 种糖果，则说明最大的甜蜜度只可能更小，需要修改二分查找的右边界。